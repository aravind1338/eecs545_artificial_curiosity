from __future__ import annotations
import os
import pandas as pd
import numpy as np
import re
from typing import List, Dict

class AgentInfo():
    """
    This class provides an abstract way to store data generated by reading the directory names of agents.

    Through static methods, it also provides the tools necessary to find the optimal setting for each
    parameter by splitting all agents according to a given parameter, and finding the average variance
    of each of those subsections.
    """

    # The different hyperparameters that we provide for our model. This list is later used
    # so we can iterate over it
    options = [
        "motivation",
        "mem_len",
        "mem_type",
        "img_size",
        "metric",
        "choochoo",
        "rate",
    ]


    def __init__(self, agent_str: str):
        """
        Params
        ------

        agent_str: str
            A string that represents all of the agent's informtion, seperated by underscores.
            This is usually the name of the directory that the agent is found in, but it could
            technically be generated manually
        """

        # Breaks the agent parameters up into its constituent parts
        info = agent_str.split("_")

        # Assigns values to various parameters
        self.agent = info[0]

        if(self.agent.lower() == "curiosity"):
            self.motivation = info[1]
            self.memory = info[2]
            self.img_size = info[3]
            self.metric = info[4]
            self.choochoo = info[5]
            self.rate = info[6]
        else:
            self.motivation = None
            self.memory = None
            self.img_size = None
            self.metric = None
            self.choochoo = None
            self.rate = None

        self.position = "_".join(info[-4:])


    def __str__(self):
        """
        Overloads the str() function
        """

        # Recreates the directory name
        if(self.motivation is not None):
            return "_".join([
                self.agent,
                self.motivation,
                self.memory,
                self.img_size,
                self.metric,
                self.choochoo,
                self.rate,
                self.position
            ])
        else:
            return "_".join([
                self.agent,
                self.position
            ])


    def __repr__(self):
        """
        Overloads the representation

        Params
        ------
        None

        Returns
        -------
        None
        """

        # Just use the same result we got from the __str__ fucntion
        return str(self)


    def get_dir(self):
        """
        Gets the name of the parent directory of the agent

        Params
        ------
        None

        Returns
        -------
        str
            The name of the directory that contains the agent
        """

        # The directory name is based on the agents position, so we just use that
        return self.position.lower().replace("agent_", "")


    def load_data(self, source_dir: str = "./"):
        """
        Loads the data for the agent from a given directory. It must be in a .csv file that has only one entry

        Params
        ------
        source_dir: str
            The directory that the file should be found in

        Returns
        -------
        None
        """

        # Reads a csv using pandas, and gets the content of the first element of the data frame
        # This gets the average path variance
        self.data = pd.read_csv(os.path.join(source_dir, self.get_dir(), str(
            self), "avg_path_variance.csv"), header=None)[0][0]


    def __lt__(self, other: AgentInfo):
        """
        Overloads the < operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self < other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data < other.data


    def __gt__(self, other):
        """
        Overloads the > operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self > other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data > other.data


    def __le__(self, other):
        """
        Overloads the <= operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self <= other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data <= other.data


    def __ge__(self, other):
        """
        Overloads the >= operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self >= other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data >= other.data


    def __eq__(self, other):
        """
        Overloads the == operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self == other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data == other.data

    def __ne__(self, other):
        """
        Overloads the != operator for comparisons

        Params
        ------
        other: AgentInfo
            The other agent that should be compared against. This is determined automatically as
            self != other

        Returns
        -------
        bool
            Whether the evaluation is true
        """

        return self.data != other.data

    @staticmethod
    def generate_agents(source_dir:str = "./results2"):
        """
        Creates all of the agents possible from a given directory and adds them to a list

        Params
        ------
        source_dir:str = "./results2"
            The directory that you want to load the agents from

        Returns
        -------
        List[AgentInfo]
            A list of all of the agents found in the given directory, expressed as AgentInfo
        """

        # All of the agents that have been successfully loaded
        agents = []

        # Get all of the position direcories
        # This excludes things like .DS_STORE ot .git
        position_dirs = [x for x in os.listdir(source_dir) if "pos_" in x]

        # Iterate over all position directories
        for dir in position_dirs:
            # Get all of the agent directories
            # As above, this excludes things like .DS_STORE ot .git
            agent_dirs = [x for x in os.listdir(
                os.path.join(source_dir, dir)) if "Pos_" in x]

            # Iterate over all agents in the agent directory
            for agent in agent_dirs:
                # Create an agent form that information
                temp_agent = AgentInfo(agent)
                # Load the data for that agent
                temp_agent.load_data(source_dir)
                # Add te agent to the list of AgentInfo
                agents.append(temp_agent)

        # Return the list of AgentInfo
        return agents

    @staticmethod
    def sort_type(t: str, agents: List[AgentInfo]):
        """
        Creates a dictionary of different implementations of the given parameter, then returns that dictionary.
        This only really operates on Curious agents, as all Random/Linear agents are discarded

        Params
        ------
        t: str
            The hyperparameter that we want to look at. It can be any of the values described in AgentInfo.options:
            - motivation
            - mem_len
            - mem_type
            - img_size
            - metric
            - choochoo
            - rate

        agents: List[AgentInfo]
            A list of AgentInfo instances that will be sorted

        Returns
        -------
        Dict[str, List[str]]
            A dictionary where the keys are settings for the given hyperparameter, and the entries are lists of
            losses based on that hyperparameter
        """

        # A dictionary to contain the results
        result = {}

        # A bunch of if statements to perform an action based on the hyperparameter chosen. This is probably
        # not the most efficient or maintainable way to implement it, but I was trying to get it done before Ted
        # ran another training session

        # They're all basically the same, so I'm just going to annotate the first one
        if(t.lower() == "motivation"):
            # Iterate over all agents
            for a in agents:
                # If their hyperparameter name is already in the dictionary
                if(a.motivation in result):
                    #  Add them to the list
                    result[a.motivation].append(a)
                # Otherwise
                else:
                    # Create a new dictionary entry with that hyperparameter
                    result[a.motivation] = [a]
        elif(t.lower() == "agent"):
            for a in agents:
                if(a.agent in result):
                    result[a.agent].append(a)
                else:
                    result[a.agent] = [a]
        # These next two are a little special because we need to split a single parameter into two options: one for
        # the memory type, and one for the memory length
        elif(t.lower() == "mem_len"):
            for a in agents:
                # We do this be breaking up the hyperparameter name into its type and its length, then grabbing the
                # length and using it to create a new name
                mem = re.sub(r'([a-zA-Z]+)(\d+)', r'Mem\2', str(a.memory))
                if(mem in result):
                    result[mem].append(a)
                else:
                    result[mem] = [a]
        elif(t.lower() == "mem_type"):
            for a in agents:
                # The same thing as above, except we're just using the memory type
                mem = re.sub(r'([a-zA-Z]+)(\d+)', r'\1', str(a.memory))
                if(mem in result):
                    result[mem].append(a)
                else:
                    result[mem] = [a]
        elif(t.lower() == "img_size"):
            for a in agents:
                if(a.img_size in result):
                    result[a.img_size].append(a)
                else:
                    result[a.img_size] = [a]
        elif(t.lower() == "metric"):
            for a in agents:
                if(a.metric in result):
                    result[a.metric].append(a)
                else:
                    result[a.metric] = [a]
        elif(t.lower() == "choochoo" or t.lower() == "train"):
            for a in agents:
                if(a.choochoo in result):
                    result[a.choochoo].append(a)
                else:
                    result[a.choochoo] = [a]
        elif(t.lower() == "rate"):
            for a in agents:
                if(a.rate in result):
                    result[a.rate].append(a)
                else:
                    result[a.rate] = [a]

        # Remove anything with the type None, since we don't want that
        result.pop(None, None)

        # Sort all of the elements
        for k in result:
            result[k].sort(reverse=True)

        # Return the resuling dictionary
        return result


    @staticmethod
    def average(lst_agents: List[AgentInfo]):
        """
        Finds the average data value for a given list of AgentInfo instances

        Params
        ------
        lst_agents: List[AgentInfo]
            A list of AgentInfo instances that we want to find the average of

        Returns
        -------
        float
            A floating-point number that represents the average data value for the agents
        """
        
        # Finds the average of the list
        return np.sum([x.data for x in lst_agents])/len(agents)


    @staticmethod
    def find_best_overall(dict_agents: Dict[str, List[AgentInfo]]):
        """
        Finds the best individual setting for each feature and then combines then to
        get the best overall collection of settings

        Params
        ------
        dict_agents: Dict[str, List[AgentInfo]]
            A dictionary where the keys are the settings for groups of agents, and values are
            lists of AgentInto

        Returns
        -------
        List[Tuple(str, float)]
            A list where every element is a tuple, where the first element is the name of the setting
            and the last element is the average path variance
        """

        # A list of the best settings
        bests = []

        # Iterate through all of the options
        for i in AgentInfo.options:
            # Create a list fo hold the averates
            averages = []
            # Break the results into the different options
            temp = AgentInfo.sort_type(i, dict_agents)

            # Iterate over the options and append the averate value to the list
            for k in temp:
                averages.append((k, AgentInfo.average(temp[k])))

            # Sort the array based on the second value
            averages.sort(key=lambda x: x[1], reverse=True)

            # Add the tuple with the highest variance to the list of bests
            bests.append(averages[0])

        # Return the list
        return bests


if __name__ == "__main__":
    agents = AgentInfo.generate_agents()
    print(AgentInfo.find_best_overall(agents))
